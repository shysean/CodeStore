package test.base.concurrency;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import org.junit.After;import org.junit.Before;import org.junit.Test;import sean.base.concurrency.LiftOff;import sean.base.concurrency.SleepingTask;public class LiftOffTest {	@Before	public void setUp() throws Exception {	}	@After	public void tearDown() throws Exception {	}	/**	 * 运行在主线程中	 * 	 * LiftOff不会产生任何内在线程能力。	 * 要实现线程行为，你必须显式地将一个任务附着岛线程上。	 */	// @Test	public void LaunchInMianThread() {		LiftOff launch = new LiftOff();		launch.run();	}		/**	 * 一个Thread会创见一个单独的执行线程，在对start的调用完成之后，它仍然会继续存在。	 */	// @Test	public void LaunchInThread(){		for (int i = 0; i < 5; i++) {					new Thread(new LiftOff()).start();		}				System.out.println("Waiting for LiftOff");	}			/**	 * Executor(执行器)管理Thread对象，简化了并发编程。	 * 非常常见的情况是,单个的Executor被用来创建和管理系统中所有任务.	 */	// @Test	public void LaunchByExecutor() {		// CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程		// 是合理Executor的首选		ExecutorService exe = Executors.newCachedThreadPool();		for(int i = 0; i < 5; i++){			exe.execute(new LiftOff());		}				// 调用shoutDown()可以防止新任务被提交给这个Executor		// 当前线程将继续运行在shutDown()被调用之前提交的所有任务.		exe.shutdown();	}		/**	 * FixedThreadPool可以一次性预先执行代价高昂的线程分配	 * FixedThreadPool使用的Thread对象数量是有界的	 */	// @Test	public void LaunchByExecutorFixedThreadPool(){//		ExecutorService exe = Executors.newFixedThreadPool(5);		ExecutorService exe = Executors.newFixedThreadPool(2);		for(int i = 0; i < 5; i++){			exe.execute(new LiftOff());		}		exe.shutdown();	}		/**	 * SingleThreadExecutor就像是线程数是1的FixedThreadPool	 * 如果向SingleThreadExecutor提交了多个任务,所有任务将使用同一线程	 * 任务按照它们呗提交的顺序执行.	 */	//@Test	public void LanuchByExecutorSingleThreadExecutor(){		ExecutorService exe = Executors.newSingleThreadExecutor();		for(int i = 0; i < 5; i++){			exe.execute(new LiftOff());		}				exe.shutdown();	}			/**	 * Test Failed!	 * Maybe SleepingTask Object be destroyed when sleep().	 * But why It's success when running in SleepingTask.java?	 * @throws InterruptedException	 */	@Test	public void SleepingTaskTest() throws InterruptedException {		ExecutorService exec = Executors.newCachedThreadPool();		for(int i = 0; i < 5; i++) {			exec.execute(new SleepingTask());		}		exec.shutdown();			}}